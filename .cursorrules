# Cursor Rules

## Commit messages

Use Conventional Commits; keep subjects short and actionable.

```
<type>(optional-scope)!: short imperative summary

[body]

[footer]
```

- Types: `feat`, `fix`, `docs`, `style`, `refactor`, `perf`, `test`, `chore`, `ci`, `build`, `revert`
- Scope: concise area in parentheses (e.g., `api`, `auth`, `ui`)
- Summary: imperative, lower-case start, no trailing period, ~50 chars
- Breaking: add `!` after type/scope and a `BREAKING CHANGE:` footer
- Issues: reference in footer (e.g., `Closes #123`)

Examples:
```
feat(auth): add login validation
fix(api): handle 504 gateway timeout
feat(api)!: change user response shape

BREAKING CHANGE: endpoint returns a nested object.
```

## Engineering principles (SOLID)

Adopt SOLID as default design guidance. Prefer simple code first; increase abstraction only when the need becomes clear.

- **Single Responsibility (S)**: a module/class/function has one reason to change.
  - Do: keep functions small and focused; extract concerns (validation, mapping, IO).
  - Avoid: multi-purpose classes, optional behaviors toggled via flags.

- **Open/Closed (O)**: open for extension, closed for modification.
  - Do: depend on interfaces, use composition, strategy/policy objects.
  - Avoid: switch/case by type that grows every time we add a new variant.

- **Liskov Substitution (L)**: subtypes must be usable wherever base types are expected.
  - Do: preserve invariants and contracts; avoid strengthening preconditions.
  - Avoid: throwing on valid base behavior or returning broader/looser results.

- **Interface Segregation (I)**: prefer small, client-specific interfaces.
  - Do: split fat interfaces; pass only what is needed.
  - Avoid: god-interfaces that force unused methods.

- **Dependency Inversion (D)**: depend on abstractions, not concretions.
  - Do: inject dependencies; isolate side-effects at boundaries.
  - Avoid: directly new-up infrastructure inside domain logic.

Checklist before merging:
- Each unit has one clear purpose and name conveys it
- No concrete infrastructure leaked into domain modules
- New behavior added via composition/polymorphism instead of editing many conditionals
- Interfaces are narrow; no unused methods

## Clean code & craftsmanship

- **Naming**: prefer full words; reflect domain language; avoid abbreviations.
- **Functions**: small, do one thing; avoid boolean flags; prefer early returns.
- **Classes/Modules**: keep public API minimal; hide internals; avoid cyclic deps.
- **Immutability**: prefer immutable data; avoid shared mutable state.
- **Error handling**:
  - Use explicit error types/Result objects where idiomatic; avoid silent failures
  - Fail fast with clear messages, include actionable context (not secrets)
- **Null/undefined**: avoid returning null; prefer Option/Maybe or explicit errors.
- **Side-effects**: keep at edges; pure core where feasible.
- **Comments**: explain why, not what; remove outdated comments; no TODOâ€”implement or ticket.
- **Formatting**: use project formatter/linters; no unrelated reformatting in PRs.

## Architecture & boundaries

- **Layers**: domain (pure), application/use-cases (orchestrate), infrastructure (IO, frameworks).
- **Boundaries**: domain does not import infrastructure; define ports/interfaces in domain.
- **Dependency rules**: inward pointing; outer layers depend on inner, not vice versa.
- **DTOs/Mappers**: isolate transport shapes from domain models; map at boundaries.
- **Configuration**: inject via environment/config objects; avoid global singletons.
- **Concurrency**: encapsulate async/parallelism; avoid leaking primitives across layers.

Recommended structure (adapt as needed):
- `domain/` entities, value-objects, domain services, ports
- `application/` use-cases, command/query handlers, orchestrations
- `infrastructure/` db/http/fs/adapters, frameworks, DI wiring
- `interfaces/` (optional) REST/GraphQL/CLI controllers, validation


## Security & privacy

- Never log secrets, tokens, or personal data; scrub or hash identifiers.
- Validate and sanitize all external input at boundaries; use allow-lists.
- Principle of least privilege for creds/permissions; rotate secrets.
- Pin dependencies; address known CVEs promptly; avoid unmaintained libs.
- Use HTTPS/TLS; verify certificates; sign webhooks; enable CSRF protection where relevant.

## Performance & reliability

- Set budgets for latency and memory in hot paths; measure before and after.
- Avoid N+1 queries; use indexes; prefer streaming/iteration for large datasets.
- Add timeouts, retries with backoff, and idempotency keys for external calls.
- Use caching thoughtfully; define invalidation strategy; bound cache size/TTL.
- Guard against unbounded concurrency; use queues or rate limits where needed.


## Conventional Commit aide-memoire

When in doubt, prefer these mappings:
- `feat(scope):` user-visible behavior or API additions
- `fix(scope):` bug fixes with tests
- `refactor(scope):` internal restructuring without behavior change
- `perf(scope):` measurable performance improvements
- `docs(scope):` docs only
- `test(scope):` tests only
- `build|ci|chore(scope):` tooling and build changes